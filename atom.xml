<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tiny Xiu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-21T19:23:22.948Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tiny Xiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何高效学习（未完成）</title>
    <link href="http://yoursite.com/2020/03/30/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/03/30/如何高效学习/</id>
    <published>2020-03-30T15:52:36.000Z</published>
    <updated>2020-10-21T19:23:22.948Z</updated>
    
    <content type="html"><![CDATA[<p>因为2019冠状病毒病（COVID-19）疫情的影响，相信除了已经工作的朋友们，大家更多的还是在家学习的较多。</p><p>独自在家学习，最令人害怕的不是空虚寂寞冷的夜。而是那无时无刻会突然跳出来干扰我们朝着梦想努力的想法。</p><p>本文将总结概括我对于学习、工作如何长时间集中注意力的一下小做法。希望对你有用。</p><a id="more"></a><p>未完成</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为2019冠状病毒病（COVID-19）疫情的影响，相信除了已经工作的朋友们，大家更多的还是在家学习的较多。&lt;/p&gt;
&lt;p&gt;独自在家学习，最令人害怕的不是空虚寂寞冷的夜。而是那无时无刻会突然跳出来干扰我们朝着梦想努力的想法。&lt;/p&gt;
&lt;p&gt;本文将总结概括我对于学习、工作如何长时间集中注意力的一下小做法。希望对你有用。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="思考" scheme="http://yoursite.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Docker 学习日记（未完成）</title>
    <link href="http://yoursite.com/2020/03/27/Docker%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/27/Docker学习日记/</id>
    <published>2020-03-27T16:49:25.000Z</published>
    <updated>2020-10-21T19:23:22.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>本文是一个 Docker 初学者学习 Docker 的过程记录。目前仅仅是学习过程中的记录并未整理和简化，内容过于干涩，后续会有相应的修改。</p></blockquote><a id="more"></a><h1 id="DAY-1"><a href="#DAY-1" class="headerlink" title="DAY 1"></a>DAY 1</h1><h2 id="明确学习目标"><a href="#明确学习目标" class="headerlink" title="明确学习目标"></a>明确学习目标</h2><ol><li><p>容器云平台的软件设计与研发工作</p></li><li><p>基于容器云的CI/CD软件</p></li><li><p>DevOps 软件系统的设计与开发</p></li><li><p>Kubernetes 云编排服务框架的研发工作</p></li></ol><p>在整个学习中首先需要明白的就是什么是容器，这引出了我们的第一个问题。</p><h2 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h2><p>容器（Container）可以理解为一个名称，用于描述有固定样式的打包好的一个整体。</p><p>而计算机中的容器，可以类比我们生活中用于出租的小隔间，容器就是这个一个个被分隔开来的小隔间。</p><p>在我们理解容器是什么之后随之而来的问题就是，原来的环境好好的，为什么要引入容器这个概念呢？它又是怎么实现的呢？</p><h2 id="为什么要引入容器"><a href="#为什么要引入容器" class="headerlink" title="为什么要引入容器"></a>为什么要引入容器</h2><p>我们引入容器的目的其实也很简单，随着计算机技术的不断更新发展，计算机系统、软件、运行环境碎片化情况越来越明显，每个用户计算机的环境都不相同，你怎么知道你的软件，能在各个机器上跑起来？如果某些老旧的模块与当前环境不兼容，那就麻烦了。</p><p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。为了让用户在使用一些软件的时候不用浪费过多的时间在配置环境上，同时也是为了灵活使用计算机性能，容器的想法就由此诞生。</p><p>其实在容器之前也有类似的，想减少用户配置环境的一些项目，但是原来的想法都比较粗暴，想的都是直接从硬件层面上虚拟出一整个机器，再在其上安装系统，这样在这个虚拟出来的电脑上就能运行一个环境完全虚拟可控的应用程序了。但是随之而来的问题也是很显著的，需要完整的从硬件层面上虚拟出一个机器再在上面套一个系统，系统内再套娃一个应用程序，这么多层虚拟，相应的计算性能的损耗也是惊人的。</p><p>其实在实际日常使用中，我们并不需要完全的虚拟出一个新的操作系统，我们需要的只是在相同系统中虚拟出一个完全隔离且适合程序的运行环境就行。所以更为轻量级的系统层虚拟化就进入了人们的视野。</p><h2 id="Docker-容器的简单实现方法"><a href="#Docker-容器的简单实现方法" class="headerlink" title="Docker 容器的简单实现方法"></a>Docker 容器的简单实现方法</h2><p>以下以Docker作为容器典型来简单描述一下，Docker容器的实现方法，容器作为系统层面的虚拟化其实并不需要完整的虚拟出一个底层程序，很多可能直接拿来公用的部分可以直接使用宿主机，很好的一个典型就是系统内核（Kernel）。对于不同的系统，系统内核也是不同的，所以Docker在不同系统的上使用的虚拟方式也有所区别。</p><p>首先，从内核共享与否</p><p>Docker在Linux上共享内核，无需虚拟化，完全支持Native功能<a href="https://docs.docker.com/engine/installation/linux/%EF%BC%89" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/</a>。 </p><p>Docker在windows上，启用Hyper-V<a href="https://docs.docker.com/docker-for-windows/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/</a>或者虚拟化技术<a href="https://docs.docker.com/toolbox/toolbox_install_windows/" target="_blank" rel="noopener">https://docs.docker.com/toolbox/toolbox_install_windows/</a>，通过虚拟机来实现，不共享windows内核。 </p><p>Docker在mac os上，同样用虚拟化技术xhyve或者virtualbox来实现（<a href="https://docs.docker.com/engine/installation/mac/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/mac/</a> ），不共享Mac OS 内核。</p><p>其次，能创建何种类型Docker</p><ol><li><p>Docker在Linux上共享内核，只能创建Linux类Docker。 </p></li><li><p>Docker在Windows上，可以创建Linux类Docker和Windows类Docker。 </p></li><li><p>Docker在Mac os上，只能创建Linux类Docker，不能创建Mac OS的Docker。</p></li></ol><p>Docker的虚拟化最简单的其实就是隔离机制，类似于用<code>chroot</code>命令讲根目录隔离一样，不过Docker运用的是内核（Kernel）3.8版本支持的一些新特性，这使得Docker在Linux上能获得几乎等同于Native的体验。</p><p>Linux下通过内核自带的Namespace与Cgroups进行实现，Windows下可通过Hyper-V进行虚拟化。</p><h1 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h1><p>对于 Docker 的核心实现原理，可以查看这篇文章，<a href="https://draveness.me/docker" target="_blank" rel="noopener">Docker 核心技术与实现原理</a>（不过目前我有很多地方都不是很读得懂。对于 Linux 内核指令及其层级关系的部分有点晦涩。）</p><p>既然大致明白 Docker 的原理，那么就要我们结合实际情况来进行学习一下镜像与容器的基本操作。</p><p>类似于数据库的增、删、改、查一样，Docker 也有几个比较常规的操作。</p><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><h3 id="获取容器"><a href="#获取容器" class="headerlink" title="获取容器"></a>获取容器</h3><p><code>docker pull [选项] [Docker Registery 地址[:端口]/]仓库名[:标签]</code></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure></p><p>说明：从 Docker Hub （如不填写指定的 Docker Registery 地址情况下默认为从 Docker Hub 上拉取镜像）上拉取，标签(tag)为 16.04 的 Ubuntu 镜像。</p><p>[选项]说明：</p><ul><li><p><strong>-a : </strong>拉取所有 tagged 镜像</p></li><li><p><strong>–disable-content-trust :</strong>忽略镜像的校验,默认开启</p></li></ul><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p><code>docker run [选项] 镜像 [命令]  [ARG...]</code></p><p>举例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm</span><br><span class="line">  ubuntu:16.04 \</span><br><span class="line">  /bin/bash</span><br></pre></td></tr></table></figure></p><p>说明：运行一个可交互的 ubuntu16.04 的镜像，镜像在运行结束后强行移除。</p><p>OPTIONS说明：</p><ul><li><p><strong>-a stdin:</strong> 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</p></li><li><p><strong>-d:</strong> 后台运行容器，并返回容器ID；</p></li><li><p><strong>-rm</strong>容器在结束后删除容器；</p></li><li><p><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用；</p></li><li><p><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</p></li><li><p><strong>-p:</strong> 指定端口映射，格式为：主机(宿主)端口:容器端口</p></li><li><p><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p></li><li><p><strong>–name=”nginx-lb”:</strong> 为容器指定一个名称；</p></li><li><p><strong>–dns 8.8.8.8:</strong> 指定容器使用的DNS服务器，默认和宿主一致；</p></li><li><p><strong>–dns-search example.com:</strong> 指定容器DNS搜索域名，默认和宿主一致；</p></li><li><p><strong>-h “mars”:</strong> 指定容器的hostname；</p></li><li><p><strong>-e username=”ritchie”:</strong> 设置环境变量；</p></li><li><p><strong>–env-file=[]:</strong> 从指定文件读入环境变量；</p></li><li><p><strong>–cpuset=”0-2” or –cpuset=”0,1,2”:</strong> 绑定容器到指定CPU运行；</p></li><li><p><strong>-m :</strong>设置容器使用内存最大值；</p></li><li><p><strong>–net=”bridge”:</strong> 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</p></li><li><p><strong>–link=[]:</strong> 添加链接到另一个容器；</p></li><li><p><strong>–expose=[]:</strong> 开放一个端口或一组端口；</p></li><li><p><strong>–volume , -v: </strong>绑定一个卷</p></li></ul><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><p><code>docker rm [选项] 容器[容器...]</code></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm ubuntu</span><br></pre></td></tr></table></figure></p><p>说明：删除一个已经结束且命名为 ubuntu 的容器。</p><p>选项说明：</p><ul><li><p><strong>-f :</strong>通过 SIGKILL 信号强制删除一个运行中的容器。</p></li><li><p><strong>-l :</strong>移除容器间的网络连接，而非容器本身。</p></li><li><p><strong>-v :</strong>删除与容器关联的卷。</p></li></ul><h2 id="初阶操作"><a href="#初阶操作" class="headerlink" title="初阶操作"></a>初阶操作</h2><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p><code>docker image ls</code></p><h3 id="镜像大小"><a href="#镜像大小" class="headerlink" title="镜像大小"></a>镜像大小</h3><p><code>docker system df</code></p><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p><code>docker start/stop/restart [OPTIONS] CONTAINER [CONTAINER...]</code></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start/stop/restart CONTAINER</span><br></pre></td></tr></table></figure></p><p>说明：启动已被停止的容器 CONTAINER /停止运行中的容器 CONTAINER /重启容器 CONTAINER。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p><code>docker exec [命令] -it [参数]</code></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it ubunut /bin/bash</span><br></pre></td></tr></table></figure></p><p>说明：进入名为 ubuntu 的容器内，并运行 bash。</p><blockquote><p>注:使用<code>docker exec</code>的好处在于，如果从这个 stdin 中退出不会导致容器停止。</p></blockquote><h3 id="删除容器（作用同上删除镜像部分）"><a href="#删除容器（作用同上删除镜像部分）" class="headerlink" title="删除容器（作用同上删除镜像部分）"></a>删除容器（作用同上删除镜像部分）</h3><p><code>docker container rm CONTAINER</code></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm ubuntu</span><br></pre></td></tr></table></figure></p><p>说明：删除名为 ubuntu 的容器。</p><p>注：<code>docker container prune</code>为删除所有处于停止状态的容器，<code>docker container ls -a</code>删除所有容器。</p><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><h3 id="Docker-镜像定制"><a href="#Docker-镜像定制" class="headerlink" title="Docker 镜像定制"></a>Docker 镜像定制</h3><p>由于 Docker 的镜像文件属性是只读，所以如果改变了由此镜像创造的 Container 能通过很简单的<code>docker diff CONTAINER</code>指令直接看到对容器存储层的改动。</p><p>也因为这种特性，Docker 也有类似于 Git 类似的版本控制管理方法，可通过<code>docker commit</code>命令，将当前状态下的 Container 保存起来，甚至于保存为镜像部署在其他环境或用于 Debug 。</p><p>举例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker commit \</span><br><span class="line"></span><br><span class="line">--author "Tiny Xiu" \</span><br><span class="line"></span><br><span class="line">--message "2020年3月29日备份" \</span><br><span class="line"></span><br><span class="line">webserver \</span><br><span class="line"></span><br><span class="line">nginx:backup001</span><br></pre></td></tr></table></figure></p><p>其中 –author 是指定修改的作者， –message 是记录本次修改的备注。这点和 Git 版本控制相似。</p><p>虽然<code>docker commit</code>命令能让我们轻松的修改一个 Docker image 但是在实际的操作中，不推荐这样进行操作。因为通过前面的学习，我们知道 Docker image 的构建是通过一层一层的 Docker 层构建上去的。通过<code>docker commit</code>来构建会徒增 Docker 的层数，消耗存储空间增加构建时间。</p><p>最优的方案就是我们自己构建自己的 <code>Dockerfile</code>。Dockerfile 是⼀个⽂本⽂件，其内包含了⼀条条的指令(Instruction)，每⼀条指令构建⼀层，因此每⼀条指令的内容，就是描述该层的构建方法。</p><p>首先先弄个最简单的例子。</p><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo '这是一个本地构建的nginx镜像'  &gt;  /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><p>说明：这里使用了 Nginx 作为基础镜像，并对其初始页面进行了修改。</p><p><strong>注</strong>：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。以 &amp;&amp; 符号连接命令，这样执行后，只会创建 1 层镜像。</p><p><strong>FROM</strong>：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p><p><strong>RUN</strong>：用于执行后面跟着的命令行命令。有以下两种格式：</p><blockquote><p>shell 格式：<br><code>RUN &lt;命令行命令&gt;</code><br><code># &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</code><br>  exec 格式：<br><code>RUN [&quot;可执行文件&quot;,  &quot;参数1&quot;,  &quot;参数2&quot;]  # 例如：  # RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</code></p></blockquote><p>类似于<strong>FROM</strong>、<strong>RUN</strong>Dockerfile 中也定义了一些其他的指令:</p><p><strong>COPY</strong></p><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径。</p><p>格式：</p><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;]  &lt;源路径1&gt;...  &lt;目标路径&gt; COPY [--chown=&lt;user&gt;:&lt;group&gt;]  [&quot;&lt;源路径1&gt;&quot;,...  &quot;&lt;目标路径&gt;&quot;]</code></p><ul><li><p><strong>[–chown=<user>:<group>]</group></user></strong>：可选参数，用户改变复制到容器内文件的拥有者和属组。</p></li><li><p><strong>&lt;源路径&gt;</strong>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：<br>COPY hom*  /mydir/ COPY hom?.txt /mydir/</p></li><li><p><strong>&lt;目标路径&gt;</strong>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。</p></li></ul><p><strong>ADD</strong></p><ul><li><p>ADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：</p></li><li><p>ADD 的优点：在执行 &lt;源文件&gt; 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 &lt;目标路径&gt;。</p></li><li>ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul><p><strong>CMD</strong></p><p>类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:</p><ul><li>CMD 在docker run 时运行。</li><li>RUN 是在 docker build。</li></ul><p><strong>作用</strong>：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。</p><p>格式：</p><p>CMD <shell 命令=""> CMD [“&lt;可执行文件或命令&gt;”,”<param1>“,”<param2>“,…] CMD [“<param1>“,”<param2>“,…]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</param2></param1></param2></param1></shell></p><p>推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。</p><p><strong>ENTRYPOINT</strong></p><p>类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。</p><p>但是, 如果运行 docker run 时使用了 –entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。</p><p><strong>优点</strong>：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。</p><p><strong>注意</strong>：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。</p><p>格式：</p><p>ENTRYPOINT [“<executeable>“,”<param1>“,”<param2>“,…]</param2></param1></executeable></p><p>可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。</p><p>示例：</p><p>假设已通过 Dockerfile 构建了 nginx:test 镜像：</p><p>FROM nginx</p><p>ENTRYPOINT [“nginx”,  “-c”]  # 定参 CMD [“/etc/nginx/nginx.conf”]  # 变参 </p><p>1、不传参运行</p><p>$ docker run  nginx:test</p><p>容器内会默认运行以下命令，启动主进程。</p><p>nginx -c /etc/nginx/nginx.conf</p><p>2、传参运行</p><p>$ docker run  nginx:test -c /etc/nginx/new.conf</p><p>容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)</p><p>nginx -c /etc/nginx/new.conf</p><p><strong>ENV</strong></p><p>设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。</p><p>格式：</p><p>ENV <key>  <value> ENV <key1>=<value1>  <key2>=<value2>…</value2></key2></value1></key1></value></key></p><p>以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：</p><p>ENV NODE_VERSION 7.2.0 RUN curl -SLO “<a href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;" target="_blank" rel="noopener">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;</a> \ &amp;&amp; curl -SLO “<a href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;" target="_blank" rel="noopener">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</a></p><p><strong>ARG</strong></p><p>构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。</p><p>构建命令 docker build 中可以用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p><p>格式：</p><p>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p><p><strong>VOLUME</strong></p><p>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。</p><p>作用：</p><ul><li>避免重要的数据，因容器重启而丢失，这是非常致命的。</li><li>避免容器不断变大。</li></ul><p>格式：</p><p>VOLUME [“&lt;路径1&gt;”,  “&lt;路径2&gt;”…] VOLUME &lt;路径&gt;</p><p>在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。</p><p><strong>EXPOSE</strong></p><p>仅仅只是声明端口。</p><p>作用：</p><ul><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。</li><li>在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</li></ul><p>格式：</p><p>EXPOSE &lt;端口1&gt;  [&lt;端口2&gt;…]</p><p><strong>WORKDIR</strong></p><p>指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。</p><p>docker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。</p><p>格式：</p><p>WORKDIR &lt;工作目录路径&gt;</p><p><strong>USER</strong></p><p>用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。</p><p>格式：</p><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><strong>HEALTHCHECK</strong></p><p>用于指定某个程序或者指令来监控 docker 容器服务的运行状态。</p><p>格式：</p><p>HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK [选项] CMD &lt;命令&gt;  :  这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。</p><p><strong>ONBUILD</strong></p><ul><li><p>用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。</p></li><li><p>格式：<code>ONBUILD &lt;其它指令&gt;</code></p></li></ul><h3 id="Docker-数据共享"><a href="#Docker-数据共享" class="headerlink" title="Docker 数据共享"></a>Docker 数据共享</h3><blockquote><p>构思怎么写啊啊啊啊啊啊啊啊</p></blockquote><h3 id="Docker-网络模式"><a href="#Docker-网络模式" class="headerlink" title="Docker 网络模式"></a>Docker 网络模式</h3><blockquote><p>构思怎么写啊啊啊啊啊啊啊啊啊，感觉日记不应该记录这么多的内容，而是更少一点，精细化。配上图文。降低理解难度那就更好了。</p></blockquote><h1 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h1><p>Docker 的三架马车 Docker Compose、Docker Machine 、Docker Swarm。所谓的三架马车指的是 Docker，官方提供的一些 Docker 管理工具，本文主要学习相关工具的使用方法。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose 是 Docker 官⽅编排（Orchestration）项⽬之⼀，负责快速的部署分布式应⽤。其代<br>码⽬前在<a href="https://github.com/docker/compose" target="_blank" rel="noopener">GitHub</a>上开源。Compose 定位是 「定义和运⾏多个 Docker 容<br>器的应⽤（Defining and running multi-container Docker applications）」，其前身是开源项⽬ Fig 。</p><p>之前我们学过编写单一的<code>Dockerfile</code>模板文件，可以很方便的定义一个单独的应用容器。然而在日常工作中经常会碰到，需要多个软件相互配合来完成某个人物的情况。这时候就需要 Compose 来满足这个需求了。它让用户通过<code>docker compose.yml</code>模板⽂件（YAML 格式）来定义⼀组相关联的应⽤容器为⼀个项⽬（project）。</p><p>Compose 中有两个重要的概念：</p><ul><li><p>服务 (<strong>service</strong>)：⼀个应⽤的容器，实际上可以包括若⼲运⾏相同镜像的容器实例。</p></li><li><p>项⽬ (<strong>project</strong>)：由⼀组关联的应⽤容器组成的⼀个完整业务单元，在 docker-compose.yml ⽂件中定义。</p></li></ul><h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><p>Compose ⽀持主流操作系统。Compose 可以通过pip、⼆进制⽂件、 Docker 容器进行安装。</p><h3 id="使⽤"><a href="#使⽤" class="headerlink" title="使⽤"></a>使⽤</h3><p>编写 Dockerfile ⽂件，内容为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.6-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD ["python", "app.py"]</span><br></pre></td></tr></table></figure><p>然后是编写 docker-compose.yml ⽂件，这个是 Compose 使⽤的主模板⽂件。这里设置了两个服务，分别是<code>Web</code>和<code>redis</code>，在编译程序时如果要实现容器内软件互联 host 处填写的是服务对应的名称。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: '3'</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:- "5000:5000"</span><br><span class="line">    volumes:- </span><br><span class="line">      .:/code</span><br><span class="line">  redis:</span><br><span class="line">    image: "redis:alpine"</span><br></pre></td></tr></table></figure><p>运⾏ compose 项⽬:</p><p><code>docker-compose up</code></p><p>此时访问本地 5000 端⼝，每次刷新⻚⾯，计数就会加 1。</p><h3 id="Compose-命令"><a href="#Compose-命令" class="headerlink" title="Compose 命令"></a>Compose 命令</h3><p>对于 Compose 来说，⼤部分命令的对象既可以是项⽬本身，也可以指定为项⽬中的服务或者容器。</p><p>如果没有特别的说明，命令对象将是项⽬，这意味着项⽬中所有的服务都会受到命令影响。</p><p>执⾏docker-compose [COMMAND] –help或者docker-compose help [COMMAND]可以查看具体某个命令的使⽤格式。</p><p>docker-compose 命令的基本的使⽤格式是:</p><p><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></p><p>命令选项：</p><ul><li><p>-f, –file FILE 指定使⽤的 Compose 模板⽂件，默认为 docker-compose.yml，可以多次指定。</p></li><li><p>-p, –project-name NAME 指定项⽬名称，默认将使⽤所在⽬录名称作为项⽬名。</p></li><li><p>–x-networking 使⽤ Docker 的可拔插⽹络后端特性</p></li><li><p>–x-network-driver DRIVER 指定⽹络后端的驱动，默认为 bridge</p></li><li><p>–verbose 输出更多调试信息。</p></li><li><p>-v, –version 打印版本并退出。</p></li></ul><p>build 格式为docker-compose build [options] [SERVICE…]。 构建（重新构建）项⽬中的服务容器。服务容器⼀旦构建后，将会带上⼀个标记名，例如对于 web 项⽬中的⼀个 db 容器，可能是 web_db。</p><p>可以随时在项⽬⽬录下运⾏ docker-compose build 来重新构建服务。选项包括：</p><ul><li><p>–force-rm 删除构建过程中的临时容器。</p></li><li><p>–no-cache 构建镜像过程中不使⽤ cache（这将加⻓构建过程）。</p></li><li><p>–pull 始终尝试通过 pull 来获取更新版本的镜像。</p></li></ul><p>config: 验证 Compose ⽂件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><p>down：此命令将会停⽌ up 命令所启动的容器，并移除⽹络</p><p>exec：进⼊指定的容器。</p><p>help：获得⼀个命令的帮助。</p><p>images：列出 Compose ⽂件中包含的镜像。</p><p>kill：格式为docker-compose kill [options] [SERVICE…]。通过发送 SIGKILL 信号来强制停⽌服务容</p><p>器。⽀持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p><p><code>docker-compose kill -s SIGINT</code></p><p>logs：格式为docker-compose logs [options] [SERVICE…]，查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使⽤不同的颜⾊来区分。可以通过 –no-color 来关闭颜⾊。该命令在调试问题的时候⼗分有⽤。</p><p>pause：格式为docker-compose pause [SERVICE…]，暂停⼀个服务容器。</p><p>port：格式为docker-compose port [options] SERVICE PRIVATE_PORT，打印某个容器端⼝所映射的公共端⼝。选项：</p><p>–protocol=proto 指定端⼝协议，tcp（默认值）或者 udp。</p><p>–index=index 如果同⼀服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p><p>ps：格式为docker-compose ps [options] [SERVICE…]，列出项⽬中⽬前的所有容器。选项：</p><p>-q 只打印容器的 ID 信息。</p><p>pull：格式为 docker-compose pull [options] [SERVICE…] ，拉取服务依赖的镜像。选项：</p><p>–ignore-pull-failures 忽略拉取镜像过程中的错误。</p><p>push：推送服务依赖的镜像到 Docker 镜像仓库。</p><p>restart：格式为docker-compose restart [options] [SERVICE…]，重启项⽬中的服务。选项：</p><p>-t, –timeout TIMEOUT 指定重启前停⽌容器的超时（默认为 10 秒）。</p><p>rm：格式为docker-compose rm [options] [SERVICE…],删除所有（停⽌状态的）服务容器。推荐先执</p><p>⾏ docker-compose stop 命令来停⽌容器。选项：</p><p>-f, –force 强制直接删除，包括⾮停⽌状态的容器。⼀般尽量不要使⽤该选项。</p><p>-v 删除容器所挂载的数据卷。</p><p>run：格式为docker-compose run [options] [-p PORT…] [-e KEY=VAL…] SERVICE [COMMAND]</p><p>[ARGS…]，在指定服务上执⾏⼀个命令。例如：</p><p><code>docker-compose run ubuntu ping docker.com</code></p><p>将会启动⼀个 ubuntu 服务容器，并执⾏ ping docker.com 命令。默认情况下，如果存在关联，则所有</p><p>关联的服务将会⾃动被启动，除⾮这些服务已经在运⾏中。</p><h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><h2 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;本文是一个 Docker 初学者学习 Docker 的过程记录。目前仅仅是学习过程中的记录并未整理和简化，内容过于干涩，后续会有相应的修改。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日记" scheme="http://yoursite.com/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Docekr" scheme="http://yoursite.com/tags/Docekr/"/>
    
  </entry>
  
  <entry>
    <title>2020 阅读计划</title>
    <link href="http://yoursite.com/2020/03/27/%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2020/03/27/阅读计划/</id>
    <published>2020-03-27T15:56:32.000Z</published>
    <updated>2020-10-21T19:23:22.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>书籍是在时代的波涛中航行的思想之船，它小心翼翼地把珍贵的货物运送给一代又一代。　<br>——弗·培根</p></blockquote><a id="more"></a><h1 id="阅读杂记"><a href="#阅读杂记" class="headerlink" title="阅读杂记"></a>阅读杂记</h1><h2 id="第一本《原则》-瑞·达利欧"><a href="#第一本《原则》-瑞·达利欧" class="headerlink" title="第一本《原则》( 瑞·达利欧)"></a>第一本<a href="https://item.jd.com/12257413.html" target="_blank" rel="noopener">《原则》( 瑞·达利欧)</a></h2><p>1/8 开始读 <a href="https://item.jd.com/12257413.html" target="_blank" rel="noopener">《原则》( 瑞·达利欧)</a>，这是一本我买了很久却一直未曾打开的书籍。希望能在阅读完之后写一篇读书笔记与思维导图。</p><h3 id="day-1"><a href="#day-1" class="headerlink" title="day 1"></a>day 1</h3><p> <a href="https://item.jd.com/12257413.html" target="_blank" rel="noopener">《原则》</a>一共分为三章，分别讲得是，作者的经历、作者的生活原则、作者的工作原则，作者认为这些原则能够帮助我们处理好生活中遇到的问题，帮助我们成为我们想成为的人。</p><p><strong>[part1 作者的经历]</strong> 作者一开始说自己学习不好 17 岁就开始从事金融投资，实际上作者只是将他平时赚来的钱用于投资罢了。作者的学习还是很棒的，毕竟也是哈佛大学金融系的研究生，作者在出生至大学的时候刚好赶上了美国股票经纪的大发展，投资股票很容易赚钱，所以他就因此获得了第一桶金，但是随后的发展出乎作者的意料，他对于未来的预测出现了严重错误造成了巨大损失。随后作者总结了 1 个原则。<strong>不要专注于「我是对的」而要专注在「我怎么知道我是对的」</strong>。随后作者总结了 4 个方法来获得成功。并且作者还强调了，失败不是终点，而失败后的自我放弃才是真正的死亡。</p><p> [ 阅读至 P38 ]</p><h3 id="day-2"><a href="#day-2" class="headerlink" title="day 2"></a>day 2</h3><p><strong>[part1 作者的经历]</strong> 作者继续表示了自己对于计算机设备的喜爱，认为计算机设备能够通过<strong>公式</strong>（现在叫算法中国叫 AI）对未来进行数据化的分析和预测，并且能够在大多数情况下比人还要精确。（强调系统化原则的重要性）作者通过计算机设备的预测与自己对未来形式的预测对计算机设备进行相互校准，让桥水公司在初期取得了部分的发展，但是这种方式也不是百分百成功的，也会有预测错误的情况，造成了巨大的损失。作者表达了对于中国的喜爱与羁绊，并对于中国市场拥有很大的期望。（其中有大部分的作者关于金融的原则与决策，但是由于我并未有金融方面的了解有点不知所云。）</p><p> [ 阅读至 P58 ]</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;书籍是在时代的波涛中航行的思想之船，它小心翼翼地把珍贵的货物运送给一代又一代。　&lt;br&gt;——弗·培根&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Flag" scheme="http://yoursite.com/categories/Flag/"/>
    
    
      <category term="阅读" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="计划" scheme="http://yoursite.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="Flag" scheme="http://yoursite.com/tags/Flag/"/>
    
  </entry>
  
  <entry>
    <title>The First Blog</title>
    <link href="http://yoursite.com/2019/01/06/The-First-Blog/"/>
    <id>http://yoursite.com/2019/01/06/The-First-Blog/</id>
    <published>2019-01-06T19:46:12.000Z</published>
    <updated>2020-10-21T19:23:22.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>无可奈何花落去，似曾相识燕归来。</p><p>——晏殊《浣溪沙》</p></blockquote><a id="more"></a><h2 id="时间如流水"><a href="#时间如流水" class="headerlink" title="时间如流水"></a>时间如流水</h2><p>时间很快的过去，快得令人不知所措。虽说过去一年过得十分匆忙但却未曾在脑海中留下经过的痕迹。却又是新的一年了，去年的 Flag 还在，今年的 Flag 又要立起来了。游戏和娱乐视频，视乎成为了我去年的娱乐一个缩影。</p><p>新年来要有些根本性的改变了，只有更加的追寻自己的内心才能获得真正的快乐。但是内心又是什么呢？它和一瞬间的冲动又有什么关系呢？平时我们都有那种一瞬间的冲动，做完之后又会后悔不已，但是在冲动的当时我们是真的想去做。所谓魔鬼实际上是自己的内心吧？冲动是魔鬼，但是在我们冲动的那一时刻我我们要怎样做才能驱散魔鬼的阴霾呢？这是新的一年我的目标之一吧<a href="让自己在冲动前思考一下">^新年任务1</a>。</p><h2 id="畏难情绪"><a href="#畏难情绪" class="headerlink" title="畏难情绪"></a>畏难情绪</h2><p>算法学习的过程好难，感觉整个脑子都要爆炸了，但是学会以后又感觉特别简单，这是为什么呢？短期记忆转化为长期记忆的原因么？真是有趣的事情呀，我要怎么做呢？</p><p>这让我想到了，<em>马太效应</em>（Matthew Effect）<br><blockquote class="blockquote-center"><p>凡有的，还要加给他，叫他有余；凡没有的，连他所有的也要夺去。<br>—— 《<a href="https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%A4%AA%E7%A6%8F%E9%9F%B3" title="马太福音" target="_blank" rel="noopener">马太福音</a>》<a href="https://zh.wikipedia.org/wiki/Category:%E9%A9%AC%E5%A4%AA%E7%A6%8F%E9%9F%B3%E7%AC%AC25%E7%AB%A0" title="Category:马太福音第25章" target="_blank" rel="noopener">第25章</a>第29节、《<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E5%8A%A0%E7%A6%8F%E9%9F%B3" title="路加福音" target="_blank" rel="noopener">路加福音</a>》<a href="https://zh.wikipedia.org/wiki/Category:%E8%B7%AF%E5%8A%A0%E7%A6%8F%E9%9F%B3%E7%AC%AC19%E7%AB%A0" title="Category:路加福音第19章" target="_blank" rel="noopener">第19章</a>第11-26节</p></blockquote><br>这真的很有趣。这种强者愈强弱者越弱之现象，即是贫者愈贫富者愈富。<a href="https://zh.wikipedia.org/zh-sg/%E9%A9%AC%E5%A4%AA%E6%95%88%E5%BA%94#cite_note-4" target="_blank" rel="noopener">[4]</a> 现实中就是指，只要获得了每一点的成功，就会产生<a href="https://zh.wikipedia.org/w/index.php?title=%E7%B4%AF%E7%A9%8D%E5%84%AA%E5%8B%A2&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">累积优势</a>，使之拥有更大的机会获得更卓越的成就。也是造就了贫富差距的原因之一。但是为什么会这样呢？然后又要如何的打破马太效应这个坚不可摧的壁垒呢？又无人可知。努力努力再努力，这句话听起来好无力呀。</p><h2 id="松鼠症"><a href="#松鼠症" class="headerlink" title="松鼠症"></a>松鼠症</h2><p>喜欢囤积资料，但是却没有时间去查看，这个问题很奇怪，和焦虑有关吧。现在的人知道得越多也就越焦虑，很奇怪，想的东西多了，就越觉得迷茫弱小与无知。和各种知识付费的APP差不多的样子，贩卖知识可以，但是贩卖焦虑就是大大的坏了。这是我为什么讨厌《得到》APP的一个重要原因。</p><h2 id="碎片化阅读"><a href="#碎片化阅读" class="headerlink" title="碎片化阅读"></a>碎片化阅读</h2><p>微博、twitter、QQ 空间、朋友圈、Fackbook、instagram 现在流式的社交网络不断的发展、变化，对我们的生活也产生了很大的影响，我们习惯了从社交媒体上去获取资讯，在社交媒体上去获取娱乐信息。众多的 信息来源、信息媒介，让我们的古老大脑无所适从，我们的注意力被各种 APP、Web 所撕扯四分五裂。</p><h3 id="碎片化阅读的影响"><a href="#碎片化阅读的影响" class="headerlink" title="碎片化阅读的影响"></a>碎片化阅读的影响</h3><p>你所接受的一切信息，构成了你的思维方式。</p><p>微博、twitter、QQ 空间、朋友圈、Fackbook、instagram 现在流式的社交网络不断的发展、变化，对我们的生活也产生了很大的影响，我们习惯了从社交媒体上去获取资讯，在社交媒体上去获取娱乐信息，这种<strong>信息的碎片化是以将复杂事物的简单化来作为代价的。</strong>它只注重了扩充“事实”，让碎片化的新鲜内容不断刺激你的大脑，让你始终处于知道新知识的喜悦中难以自拔，你不需要付出思考，就可以轻易获得太多内容，这种快感总会让你难以自拔，所以才有我们停不下来的刷朋友圈、刷微博的习惯。<strong>这些碎片化信息看似内容很多，但遗忘的更快。</strong>你以为你学到很多知识，但其实什么也没有得到。</p><p>并且当你习惯只去看待肤浅的“事实”，而不去思考，不去将各种知识的“联系”起来，那你的思考能力总是不能提升，甚至反而会下降。<strong>你会习惯用孤立的信息去看待问题，习惯了简单的因果逻辑的思考方式，而失去了对复杂事物的思维能力。</strong>这样下去，当某天你轻信了某人的欺骗、转发了网上的谣言，也就不足为怪了。</p><p>更严重的是，如果你失去了对于复杂事物的思考能力，那无论你接触什么知识，那都是孤立的，碎片化的，你没有能力将知识联系起来，学习也是事倍功半，那又何其悲哀。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;无可奈何花落去，似曾相识燕归来。&lt;/p&gt;
&lt;p&gt;——晏殊《浣溪沙》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="时间" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4/"/>
    
      <category term="2019 新年计划" scheme="http://yoursite.com/tags/2019-%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
    
      <category term="碎片化" scheme="http://yoursite.com/tags/%E7%A2%8E%E7%89%87%E5%8C%96/"/>
    
      <category term="松鼠症" scheme="http://yoursite.com/tags/%E6%9D%BE%E9%BC%A0%E7%97%87/"/>
    
  </entry>
  
</feed>
